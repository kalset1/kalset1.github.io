<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaloyan Stefanov</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }

        header {
            background-color: #1a1a1a;
            color: #fff;
            padding: 20px;
            text-align: center;
            width : 100%;
        }

        header h1 {
            margin: 0;
            font-size: 2.5em;
        }

        header p {
            margin: 0;
            font-size: 1.2em;
        }

        nav {
            background: #333;
            padding: 10px;
            text-align: center;
        }

        nav a {
            color: #fff;
            text-decoration: none;
            margin: 0 15px;
            font-size: 1.2em;
        }

        nav a:hover {
            color: #f39c12;
        }

        main {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        section {
            margin-bottom: 30px;
        }

        h2 {
            margin: 0 0.5px;
            color: #1a1a1a;
        }

        h3 {
            margin: 0 0.5px;
            color: #1a1a1a;
            font-size: 0.81em;
        }

        .content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px auto;
        }

        .video-container {
            text-align: center;
        }

        .video-container iframe {
            width: 100%;
            max-width: 560px;
            height: 315px;
        }

        footer {
            text-align: center;
            padding: 10px;
            background: #1a1a1a;
            color: #fff;
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <header>
        <h1>Kaloyan Stefanov</h1>
        <p>Exploring Computer Systems, Hardware Design, and Robotics</p>
    </header>
    <nav>
        <a href="index.html">Home</a>
        <a href="#">Projects</a>
        <a href="contact.html">Contact</a>
    </nav>
    <main>
        <h1>My Projects</h1>

        <div class="project">
            <h2>C0 Compiler (15-411 Project)</h2>
            <h3>Spring 2025</h3>
            <div style="text-align: center;">
                <img src="images/randallboggs.jpeg" alt="Randall boggs, our team name and mascot for the compiler (everyone had to pick a disney character)." style="width: 100%; max-width: 600px; height: auto;">
                <figcaption>Randall boggs, our team name and mascot for the compiler (everyone had to pick a disney character).</figcaption>
            </div>
            <div class="project-description">
                <p>
                    During my time in Carnegie Mellon's compiler design course (15-411), my partner and I built a compiler for C0 from the ground up.
                    Our final compiler supports the C0 language, including conditionals, loops, functions, and memory operations. 
                    It goes through a couple of different phases: initially, our source code gets parsed and converted into an AST. This 
                    was done using the Rust library lalrpop. This gave us some headaches, mainly from triyng to write our rules to align with
                    the grammar specified in C0, which was eventually NOT context free. We then generate an elaborated AST, to simplify the possible
                    statements for later passes. In our next stage we typecheck the elaborated AST, ensuring that the program is behaving properly.
                    This is done through converting a set of judgements and rules for how the program should behave into iterative passes through
                    our elaborated AST. Once the program typechecks successfully, an intermediate representation is generated and tail-call recursion is identified and inserted. 
                    Internally, we call this the "forest" representation, since we take in our elaborated AST and recursively generate commands (preserving side effects) 
                    by traversing the tree. After our forest representation, we know what the sizes of these variables will be in the final assembly,
                    and thus can interpolate the sizes for our entire IR. Once these sizes are generated, we create our abstract assembly. While the forest 
                    representation still had variables, our abstract assembly operates only on temporaries. After this conversion, we convert the abstract
                    assembly to SSA and run a series of optimizations on this new SSA form: peephole optimizations (such as t0 = t1 * 1 -> t0 = t1), sparse
                    constant and copy propagation, aggressive dead code elimination, and strength reductions. We then convert back out of SSA, by inserting parallel copies
                    for any phi moves (a special kind of move instruction necessary in SSA to deal with control flow) and then removing the phi instructions from our abstract assembly. 
                    We then add in hard registers (since we targeting x86-64) for specific instructions, such as IDIV, so that our final assembly code will behave correctly.
                    Finally, we convert our abstract assembly to x86-64 assembly, taking special care to remove unnecessary instructions and perform efficient operations.

                    <br>
                    <br>

                    Some reflection: this was by far the hardest project I've ever done at CMU. As any of my friends can verify,
                    almost everyday I was locked up in my room, Gates, or some other unknown area working on this compiler. I wrote 
                    11,000+ lines of Rust code, with my only previous experience being the beginner project in the Book. With that said,
                    it is by far my favorite class I've ever taken at CMU. To work on a project continously over the semester was the most rewarding
                    experience I've had yet, and learning more about the Rust language as I built the compiler was awesome. The all-nighters were 
                    slightly diabolical but I would do it all over again if I could :) 
                </p>
            </div>
        </div>

        <h2>RISC-V Pipelined Processor (18-447 Project)</h2>
            <h3>Spring 2025</h3>
            <div style="text-align: center;">
                <img src="images/riscv.png" alt="RISC-V, the ISA we targeted with our CPU" style="width: 100%; max-width: 600px; height: auto;">
                <figcaption>RISC-V, the ISA we targeted with our CPU</figcaption>
            </div>
            <div class="project-description">
                <p>
                    In Introduction to Computer Architecture (18-447), my team and I designed and developed a synthesizable
                    6-stage pipelined RISC-V processor in SystemVerilog. From an initial RTL specification of a single-cycle processor
                    to a processor with branch prediction, data forwarding, stalling, and a data cache with prefetching, our team built the processor
                    from the ground up in a single semester. After the initial single-cycle implementation, we continued to add features 
                    to improve our processors's efficiency, with the techniques we learned about in class. Four our final lab, our class
                    had a competition based on MIPS and Area/Power. In this competition, my team and I achieved a throughput of 
                    263 MIPS on a variety of C-language benchmark tests, testing our processors's ability on large programs
                    with significant control-flow and memory operations. Throughout my time with this project, I also attended
                    the Superscalar club, a class gathering which would meet on Friday to go over how more advanced CPUs function,
                    with features like out-of-order processing of instructions and what it meant for a processor to be "superscalar". 

                    <br>
                    <br>
                    
                    Learning more about computer architecture and the choices that people had to make when designing
                    processors connected the picture for me. It was the bridge between software and hardware that I had
                    always been most interested in, and taking a course on compilers gave me an even deeper
                    understanding for how software and hardware can interact on the stack, along with how the design choices
                    of computer architects can influence this entire procedure. 
                </p>
            </div>
        </div>
        
        <div class="project">
            <h2>Embedded Rover (18-349 Project)</h2>
            <h3>Fall 2024</h3>
            <div style="text-align: center;">
                <img src="images/embedded_rover.jpg" alt="The Embedded Rover: Complete with fully functioning HLP RTOS and PID control." style="width: 100%; max-width: 600px; height: auto;">
                <figcaption>The Embedded Rover: Complete with fully functioning HLP RTOS and PID control.</figcaption>
            </div>
            <!-- <div class = 'video-container'>
                <iframe src=../videos/embedded_rover/mp4"" frameborder="0" allowfullscreen></iframe>
                <p>The Embedded Rover: Complete with fully functioning HLP RTOS and PID control.</p>
            </div> -->
            <div class="project-description">
                <p>
                    Throughout my semester in Introduction to Embedded Systems (18-349), 
                    we continued to add functionality to our STM32 microcontroller. Eventually, we were 
                    able to completely control a car through a personal implementation of a
                    Highest Locker Protocol (HLP), real-time operating  system. This system featured a dynamic scheduler with support for user-defined
                    threads, which allowed us to interface with the motors and monitor their
                    status and speed through motor encoder inputs. To interact with different functions
                    in the car, we designed and fabricated our own PCB. Through this, we were able
                    to implement PID control of the motors and correctly adjust our wheel speed
                    based on outside error. 
                </p>
            </div>
        </div>

        <div class="project">
            <h2>kEngine</h2>
            <h3>November 2024</h3>
            <!-- <img src="path/to/your/image1.jpg" alt="Project Image 1"> -->
            <div class = 'video-container'>
                <iframe src="../videos/kengine.mp4" frameborder="0" allowfullscreen></iframe>
                <p>kEngine: A simple 3D engine written entirely with NumPy and Pygame.</p>
            </div>
            <div class="project-description">
                <p>
                    Through this project, I developed a simple 3D engine in Python 
                    that was capable of displaying an arbitrary 3D figure given a 
                    set of 3D vertex points and faces described. Restrictions existed: 
                    no easy library implementation or quick solution for mapping 3D 
                    points to the 2D image plane was allowed, and instead had to be manually
                    calculated. This was done through the use of coordinate frames (namely 
                    a camera and world frame), along with a perspective projection matrix. 
                    Once this was complete, 3D points could successfully be converted to 2D
                    and displayed. However, rotation was also necessary. To implement this,
                    I calculated a rotation matrix based on the change in the user's mouse
                    position. I then applied this matrix repeatedly to the vertex points,
                    allowing for a consistently updated and rotatable shape. The final piece
                    of the puzzle was shading each face of the shape, which can be done through
                    exploiting the geometry of the face. Since each face is composed of three points,
                    we can create a plane in three dimensions; if we have a plane, we can also
                    create a normal vector. When considering lighting, we can take the dot product
                    of this normal vector with the "lighting" vector to determine a lighting score:
                    after normalization of the two vectors, we have a range from -1 to 1 which can 
                    determine the shading color we should apply to each face. For this project,
                    I assumed that this lighting vector would be coming out of the shape and 
                    towards the camera. Here, another idea must be implemented: if our dot product 
                    is less than or equal to 0, we have a face that should not be shown. 
                    To conceptualize this, imagine a face on the back of the object: its normal
                    would be pointing into the screen (the negative z-axis, in this case), while the 
                    light vector is point towards the screen (the positive z-axis). It is clear that in this 
                    case we do not want to shade in the face (as it is not visible to the user), and this is 
                    exactly when the dot product will be negative. Additionally, the dot product will be 0
                    when these two vectors are perpendicular: we can see that this is the case when the face 
                    is orthogonal to the user's view, and thus should also not be shown. After this,
                    we have a simple 3D engine built entirely with NumPy and Pygame, capable of displaying
                    an arbitrary shape and shading it in!
                </p>
            </div>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2024 Kaloyan Stefanov. All rights reserved.</p>
    </footer>
</body>
</html>